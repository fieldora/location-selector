<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Mapbox Location Picker</title>
    <script src='https://api.mapbox.com/mapbox-gl-js/v2.6.1/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v2.6.1/mapbox-gl.css' rel='stylesheet' />
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
        }
        #map {
            width: 100%;
            height: 100vh;
        }
        /* Custom search box styling */
        #search-container {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1;
            width: 300px;
            max-width: calc(100% - 60px);
            display: flex;
            background-color: white;
            border-radius: 4px;
            box-shadow: 0 0 0 2px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        #search-input {
            flex-grow: 1;
            padding: 10px;
            border: none;
            font-size: 16px;
            box-sizing: border-box;
            margin: 0;
        }
        #search-input.is-coordinates {
            color: #3880ff;
            font-weight: 500;
        }
        #search-input:focus {
            outline: none;
        }
        #search-button {
            width: 40px;
            min-width: 40px;
            border: none;
            background-color: #3880ff;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #search-button:hover {
            background-color: #2970e6;
        }
        /* Search icon */
        .search-icon {
            width: 18px;
            height: 18px;
            position: relative;
            display: inline-block;
        }
        .search-icon:before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 12px;
            height: 12px;
            border: 2px solid white;
            border-radius: 50%;
        }
        .search-icon:after {
            content: '';
            position: absolute;
            top: 13px;
            left: 13px;
            width: 2px;
            height: 6px;
            background-color: white;
            transform: rotate(-45deg);
        }
        #status-message {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            border-radius: 4px;
            font-weight: 500;
            z-index: 9999;
            display: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            max-width: 80%;
            text-align: center;
            word-break: break-word;
        }
        .success {
            background-color: #4CAF50;
            color: white;
        }
        .error {
            background-color: #F44336;
            color: white;
        }
        .loading {
            background-color: #2196F3;
            color: white;
        }
        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
        }
        .spinner {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Clear button */
        #clear-input {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
            color: #666;
            padding: 0 8px;
            display: none;
        }
        #clear-input:hover {
            color: #333;
        }
        /* Debug console */
        #debug-toggle {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            z-index: 10;
            font-size: 14px;
        }
        #debug-console {
            position: absolute;
            bottom: 50px;
            right: 10px;
            width: 400px;
            max-width: 80%;
            height: 300px;
            background-color: rgba(0, 0, 0, 0.85);
            color: #0f0;
            border-radius: 4px;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            overflow-y: auto;
            z-index: 10;
            display: none;
        }
        #debug-console p {
            margin: 5px 0;
            word-break: break-word;
        }
        #debug-clear {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 12px;
        }
        .log-info { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #F44336; }
        .log-debug { color: #03A9F4; }
    </style>
</head>
<body>
    <div id="loading-overlay">
        <div class="spinner"></div>
    </div>
    <div id="search-container">
        <input type="text" id="search-input" placeholder="Search address or coordinates">
        <button id="clear-input">&times;</button>
        <button id="search-button" title="Search">
            <span class="search-icon"></span>
        </button>
    </div>
    <div id='map'></div>
    <div id='status-message'></div>
    
    <!-- Debug elements -->
    <button id="debug-toggle">Show Debug Console</button>
    <div id="debug-console">
        <button id="debug-clear">Clear</button>
    </div>

    <script>
        /**
         * Logger - Custom logging utility for debugging
         */
        class Logger {
            constructor() {
                this.console = document.getElementById('debug-console');
                this.isEnabled = false;
                this.maxEntries = 100;
                this.networkLogs = [];  // Store network request logs
                
                // Initialize debug console
                this.setupDebugConsole();
            }
            
            setupDebugConsole() {
                const toggleButton = document.getElementById('debug-toggle');
                const clearButton = document.getElementById('debug-clear');
                
                toggleButton.addEventListener('click', () => {
                    this.isEnabled = !this.isEnabled;
                    this.console.style.display = this.isEnabled ? 'block' : 'none';
                    toggleButton.textContent = this.isEnabled ? 'Hide Debug Console' : 'Show Debug Console';
                    
                    // If enabled, enhance console with network monitoring tab
                    if (this.isEnabled && !document.getElementById('debug-tabs')) {
                        this.enhanceDebugConsole();
                    }
                });
                
                clearButton.addEventListener('click', () => {
                    this.clear();
                });
                
                // Monitor all network requests
                this.setupNetworkMonitoring();
            }
            
            enhanceDebugConsole() {
                // Add tabs to the debug console
                const tabsHtml = `
                    <div id="debug-tabs" style="display:flex; margin-bottom:10px; border-bottom:1px solid #444;">
                        <button id="tab-logs" class="debug-tab active" style="flex:1; background:none; border:none; color:white; padding:8px; cursor:pointer; border-bottom:2px solid #03A9F4;">Logs</button>
                        <button id="tab-network" class="debug-tab" style="flex:1; background:none; border:none; color:white; padding:8px; cursor:pointer;">Network</button>
                        <button id="tab-state" class="debug-tab" style="flex:1; background:none; border:none; color:white; padding:8px; cursor:pointer;">State</button>
                    </div>
                    <div id="debug-content" style="overflow-y:auto; height:calc(100% - 40px);">
                        <div id="content-logs" class="tab-content" style="display:block;"></div>
                        <div id="content-network" class="tab-content" style="display:none;">
                            <table style="width:100%; border-collapse:collapse; font-size:11px;">
                                <thead>
                                    <tr>
                                        <th style="text-align:left; padding:5px; border-bottom:1px solid #444;">Time</th>
                                        <th style="text-align:left; padding:5px; border-bottom:1px solid #444;">URL</th>
                                        <th style="text-align:left; padding:5px; border-bottom:1px solid #444;">Status</th>
                                        <th style="text-align:left; padding:5px; border-bottom:1px solid #444;">Duration</th>
                                    </tr>
                                </thead>
                                <tbody id="network-log-table"></tbody>
                            </table>
                        </div>
                        <div id="content-state" class="tab-content" style="display:none;">
                            <div id="current-state"></div>
                        </div>
                    </div>
                `;
                
                this.console.innerHTML = tabsHtml + this.console.innerHTML;
                
                // Move existing log entries
                const logContent = document.getElementById('content-logs');
                const entries = Array.from(this.console.querySelectorAll('p:not(#debug-clear)'));
                entries.forEach(entry => logContent.appendChild(entry));
                
                // Setup tab switching
                document.querySelectorAll('.debug-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        // Update active tab styling
                        document.querySelectorAll('.debug-tab').forEach(t => {
                            t.style.borderBottom = 'none';
                            t.classList.remove('active');
                        });
                        tab.classList.add('active');
                        tab.style.borderBottom = '2px solid #03A9F4';
                        
                        // Show appropriate content
                        const contentId = 'content-' + tab.id.split('-')[1];
                        document.querySelectorAll('.tab-content').forEach(content => {
                            content.style.display = 'none';
                        });
                        document.getElementById(contentId).style.display = 'block';
                        
                        // Refresh state tab if needed
                        if (contentId === 'content-state') {
                            this.updateStateTab();
                        }
                    });
                });
                
                // Update clear button position
                const clearBtn = document.getElementById('debug-clear');
                if (clearBtn) {
                    this.console.appendChild(clearBtn);
                }
            }
            
            setupNetworkMonitoring() {
                // Store original fetch
                const originalFetch = window.fetch;
                
                // Override fetch to monitor all requests
                window.fetch = (...args) => {
                    const url = args[0];
                    const options = args[1] || {};
                    
                    // Create an entry for this request
                    const requestId = Date.now() + Math.random().toString(36).substring(2, 9);
                    const requestData = {
                        id: requestId,
                        url: typeof url === 'string' ? url : url.url,
                        method: options.method || 'GET',
                        startTime: Date.now(),
                        status: 'pending',
                        duration: 0
                    };
                    
                    this.networkLogs.push(requestData);
                    this.updateNetworkTab();
                    
                    // Call the original fetch
                    return originalFetch(...args)
                        .then(response => {
                            // Update the request data
                            const requestIndex = this.networkLogs.findIndex(r => r.id === requestId);
                            if (requestIndex >= 0) {
                                this.networkLogs[requestIndex].status = response.status;
                                this.networkLogs[requestIndex].statusText = response.statusText;
                                this.networkLogs[requestIndex].endTime = Date.now();
                                this.networkLogs[requestIndex].duration = this.networkLogs[requestIndex].endTime - this.networkLogs[requestIndex].startTime;
                                this.updateNetworkTab();
                            }
                            return response;
                        })
                        .catch(error => {
                            // Update the request data with error info
                            const requestIndex = this.networkLogs.findIndex(r => r.id === requestId);
                            if (requestIndex >= 0) {
                                this.networkLogs[requestIndex].status = 'ERROR';
                                this.networkLogs[requestIndex].statusText = error.message;
                                this.networkLogs[requestIndex].endTime = Date.now();
                                this.networkLogs[requestIndex].duration = this.networkLogs[requestIndex].endTime - this.networkLogs[requestIndex].startTime;
                                this.updateNetworkTab();
                            }
                            throw error;
                        });
                };
            }
            
            updateNetworkTab() {
                const networkTable = document.getElementById('network-log-table');
                if (!networkTable) return;
                
                // Clear table
                networkTable.innerHTML = '';
                
                // Add the most recent 20 network logs
                const recentLogs = this.networkLogs.slice(-20).reverse();
                
                recentLogs.forEach(log => {
                    const row = document.createElement('tr');
                    
                    // Determine row color based on status
                    if (log.status >= 400 || log.status === 'ERROR') {
                        row.style.color = '#F44336'; // Red for errors
                    } else if (log.status >= 300) {
                        row.style.color = '#FFC107'; // Yellow for redirects
                    } else if (log.status >= 200) {
                        row.style.color = '#4CAF50'; // Green for success
                    }
                    
                    // Create a short URL for display
                    let displayUrl = log.url;
                    try {
                        // Extract just the pathname
                        const urlObj = new URL(log.url);
                        displayUrl = urlObj.pathname;
                        // If it's the Glide API, highlight it
                        if (urlObj.hostname.includes('glideapp.io')) {
                            row.style.fontWeight = 'bold';
                        }
                    } catch (e) {
                        // Use the full URL if parsing fails
                    }
                    
                    // Truncate long URLs
                    if (displayUrl.length > 30) {
                        displayUrl = displayUrl.substring(0, 27) + '...';
                    }
                    
                    row.innerHTML = `
                        <td style="padding:5px; border-bottom:1px solid #333;">${new Date(log.startTime).toLocaleTimeString()}</td>
                        <td style="padding:5px; border-bottom:1px solid #333;" title="${log.url}">${displayUrl}</td>
                        <td style="padding:5px; border-bottom:1px solid #333;">${log.status} ${log.statusText || ''}</td>
                        <td style="padding:5px; border-bottom:1px solid #333;">${log.duration}ms</td>
                    `;
                    
                    networkTable.appendChild(row);
                });
            }
            
            updateStateTab() {
                const stateElement = document.getElementById('current-state');
                if (!stateElement || !window.app) return;
                
                try {
                    // Get current app state
                    const state = {
                        mapMoveInProgress: window.app.mapMoveInProgress,
                        lastMapUpdate: window.app.lastMapUpdate,
                        updateInProgress: window.app._updateInProgress,
                        config: { ...window.app.config }
                    };
                    
                    // Remove sensitive information
                    if (state.config.glideToken) {
                        state.config.glideToken = '***HIDDEN***';
                    }
                    if (state.config.mapboxToken) {
                        state.config.mapboxToken = '***HIDDEN***';
                    }
                    
                    // Add marker info if available
                    if (window.app.marker) {
                        const lngLat = window.app.marker.getLngLat();
                        state.marker = {
                            latitude: lngLat.lat,
                            longitude: lngLat.lng
                        };
                    }
                    
                    // Display the state as formatted JSON
                    stateElement.innerHTML = `<pre style="margin:0; white-space:pre-wrap;">${JSON.stringify(state, null, 2)}</pre>`;
                } catch (e) {
                    stateElement.innerHTML = `<p class="log-error">Error getting state: ${e.message}</p>`;
                }
            }
            
            log(message, type = 'info', data = null) {
                // Always log to browser console
                const consoleMethod = type === 'error' ? console.error : 
                                    type === 'warn' ? console.warn : 
                                    type === 'debug' ? console.debug : console.log;
                
                if (data) {
                    consoleMethod(`[${type.toUpperCase()}] ${message}`, data);
                } else {
                    consoleMethod(`[${type.toUpperCase()}] ${message}`);
                }
                
                // Add to debug console if enabled
                if (this.console) {
                    const entry = document.createElement('p');
                    entry.className = `log-${type}`;
                    
                    const timestamp = new Date().toLocaleTimeString();
                    let logMessage = `[${timestamp}] ${message}`;
                    
                    if (data) {
                        try {
                            const jsonData = JSON.stringify(data, null, 2);
                            logMessage += `\n${jsonData}`;
                        } catch (e) {
                            logMessage += `\n[Object data cannot be stringified]`;
                        }
                    }
                    
                    entry.innerText = logMessage;
                    
                    // Add to the logs tab content if it exists
                    const logsContent = document.getElementById('content-logs');
                    if (logsContent) {
                        logsContent.appendChild(entry);
                    } else {
                        this.console.appendChild(entry);
                    }
                    
                    // Auto-scroll to bottom
                    if (logsContent) {
                        logsContent.scrollTop = logsContent.scrollHeight;
                    } else {
                        this.console.scrollTop = this.console.scrollHeight;
                    }
                    
                    // Limit number of entries
                    const entries = logsContent ? 
                        logsContent.querySelectorAll('p') : 
                        this.console.querySelectorAll('p:not(#debug-clear)');
                        
                    while (entries.length > this.maxEntries) {
                        if (logsContent) {
                            logsContent.removeChild(entries[0]);
                        } else if (entries.length > 0) {
                            entries[0].remove();
                        }
                    }
                }
            }
            
            info(message, data = null) {
                this.log(message, 'info', data);
            }
            
            warn(message, data = null) {
                this.log(message, 'warn', data);
            }
            
            error(message, data = null) {
                this.log(message, 'error', data);
            }
            
            debug(message, data = null) {
                this.log(message, 'debug', data);
            }
            
            clear() {
                if (document.getElementById('content-logs')) {
                    document.getElementById('content-logs').innerHTML = '';
                } else if (this.console) {
                    // Remove all children except the clear button and tabs
                    while (this.console.querySelector('p:not(.debug-tab):not(#debug-clear)')) {
                        this.console.querySelector('p:not(.debug-tab):not(#debug-clear)').remove();
                    }
                }
                this.info('Console cleared');
            }
        }
        
        /**
         * LocationPicker - Main application class
         */
        class LocationPicker {
            constructor() {
                // Initialize logger
                this.logger = new Logger();
                
                // App state
                this.map = null;
                this.marker = null;
                this.config = {};
                this.mapEventTimers = {}; // Store timers for different map events
                this.mapMoveInProgress = false; // Flag to track map movement
                this.lastMapUpdate = 0; // Timestamp of last map update
                
                // Init app
                this.init();
            }
            
            /**
             * Initialize the application
             */
            init() {
                this.logger.info('Application initializing...');
                
                try {
                    // Parse and validate URL parameters
                    this.parseUrlParameters();
                    
                    // Setup map
                    this.initMap();
                    
                    // Setup event listeners
                    this.setupEventListeners();
                    
                    this.logger.info('Application initialized successfully');
                } catch (error) {
                    this.handleInitializationError(error);
                }
            }
            
            /**
             * Parse URL parameters and validate required ones
             */
            parseUrlParameters() {
                this.logger.debug('Parsing URL parameters');
                
                const urlParams = new URLSearchParams(window.location.search);
                
                // Required parameters
                this.config.mapboxToken = urlParams.get('mapboxToken');
                this.config.glideToken = urlParams.get('glideToken');
                this.config.appId = urlParams.get('appId');
                this.config.tableId = urlParams.get('tableId');
                this.config.rowId = urlParams.get('rowId');
                this.config.columnName = urlParams.get('columnName');
                
                // Optional parameters with defaults
                this.config.initialLat = parseFloat(urlParams.get('lat')) || 37;
                this.config.initialLng = parseFloat(urlParams.get('lng')) || -95;
                this.config.initialZoom = parseInt(urlParams.get('zoom')) || 4;
                
                // Validate required parameters
                const requiredParams = ['mapboxToken', 'glideToken', 'appId', 'tableId', 'rowId', 'columnName'];
                const missingParams = requiredParams.filter(param => !this.config[param]);
                
                if (missingParams.length > 0) {
                    throw new Error(`Missing required parameters: ${missingParams.join(', ')}`);
                }
                
                this.logger.info('URL parameters parsed successfully', {
                    appId: this.config.appId,
                    tableId: this.config.tableId,
                    initialPosition: {
                        lat: this.config.initialLat,
                        lng: this.config.initialLng,
                        zoom: this.config.initialZoom
                    }
                });
            }
            
            /**
             * Initialize Mapbox map
             */
            initMap() {
                this.logger.debug('Initializing Mapbox map');
                
                mapboxgl.accessToken = this.config.mapboxToken;
                
                this.map = new mapboxgl.Map({
                    container: 'map',
                    style: 'mapbox://styles/mapbox/satellite-streets-v11',
                    center: [this.config.initialLng, this.config.initialLat],
                    zoom: this.config.initialZoom
                });
                
                // Add navigation controls
                this.map.addControl(new mapboxgl.NavigationControl(), 'top-right');
                
                // Setup map event handlers
                this.map.on('load', () => this.handleMapLoad());
                this.map.on('error', (e) => {
                    this.logger.error('Mapbox map error', e);
                    this.showStatus('Error loading map: ' + e.error.message, 'error');
                });
                
                // Add click handler with debouncing
                this.map.on('click', this.debounce((e) => this.handleMapClick(e), 300));
                
                this.logger.info('Mapbox map initialized');
            }
            
            /**
             * Handle map load event
             */
            handleMapLoad() {
                this.logger.info('Map loaded successfully');
                document.getElementById('loading-overlay').style.display = 'none';
                
                // Add user location control
                this.setupGeolocationControl();
                
                // Setup debounced event handling for map movements
                this.setupDebouncedMapEvents();
                
                // Show welcome message
                this.showStatus('Map loaded successfully. Click on the map to select a location.', 'success', 3000);
            }
            
            /**
             * Setup debounced map events to reduce event frequency
             */
            setupDebouncedMapEvents() {
                // Use a single debounced handler for all map movement events
                const debouncedMapMovement = this.debounce(() => {
                    this.logger.debug('Map movement debounced event triggered');
                    this.mapMoveInProgress = false;
                }, 1000); // 1 second debounce
                
                // Track when map movement starts
                const mapMoveStart = () => {
                    if (!this.mapMoveInProgress) {
                        this.mapMoveInProgress = true;
                        this.logger.debug('Map movement started');
                    }
                };
                
                // Apply to map movement events
                this.map.on('movestart', mapMoveStart);
                this.map.on('move', mapMoveStart);
                this.map.on('moveend', debouncedMapMovement);
                
                this.map.on('zoomstart', mapMoveStart);
                this.map.on('zoom', mapMoveStart);
                this.map.on('zoomend', debouncedMapMovement);
                
                this.map.on('dragstart', mapMoveStart);
                this.map.on('drag', mapMoveStart);
                this.map.on('dragend', debouncedMapMovement);
                
                this.map.on('pitchstart', mapMoveStart);
                this.map.on('pitch', mapMoveStart);
                this.map.on('pitchend', debouncedMapMovement);
                
                this.map.on('rotatestart', mapMoveStart);
                this.map.on('rotate', mapMoveStart);
                this.map.on('rotateend', debouncedMapMovement);
                
                this.logger.info('Debounced map event handlers setup complete');
            }
            
            /**
             * Setup geolocation control
             */
            setupGeolocationControl() {
                this.logger.debug('Setting up geolocation control');
                
                const geolocateControl = new mapboxgl.GeolocateControl({
                    positionOptions: {
                        enableHighAccuracy: true,
                        timeout: 15000
                    },
                    trackUserLocation: false,
                    showUserLocation: true,
                    showAccuracyCircle: true
                });
                
                this.map.addControl(geolocateControl, 'top-right');
                
                // Error handling for geolocation
                geolocateControl.on('error', (e) => {
                    let errorMsg = 'Unable to determine your location';
                    
                    if (e.code === 1) { // PERMISSION_DENIED
                        errorMsg = 'Location access denied. Please enable location services in your browser settings.';
                    } else if (e.code === 2) { // POSITION_UNAVAILABLE
                        errorMsg = 'Your location is currently unavailable.';
                    } else if (e.code === 3) { // TIMEOUT
                        errorMsg = 'Location request timed out. Please try again.';
                    }
                    
                    this.logger.error('Geolocation error', { code: e.code, message: errorMsg });
                    this.showStatus(errorMsg, 'error');
                });
                
                // Handle successful geolocation with debouncing
                let geolocateTimeoutId = null;
                geolocateControl.on('geolocate', (position) => {
                    // Clear any pending timeouts
                    if (geolocateTimeoutId) {
                        clearTimeout(geolocateTimeoutId);
                    }
                    
                    // Set a new timeout
                    geolocateTimeoutId = setTimeout(() => {
                        const latitude = position.coords.latitude;
                        const longitude = position.coords.longitude;
                        
                        this.logger.info('User geolocation successful (debounced)', { lat: latitude, lng: longitude });
                        
                        // Add marker at user's location
                        this.addOrUpdateMarker(longitude, latitude);
                        this.debouncedUpdateGlideTable(latitude, longitude);
                        
                        geolocateTimeoutId = null;
                    }, 500);
                });
                
                this.logger.info('Geolocation control setup complete');
            }
            
            /**
             * Setup event listeners for UI elements
             */
            setupEventListeners() {
                this.logger.debug('Setting up event listeners');
                
                const searchInput = document.getElementById('search-input');
                const clearButton = document.getElementById('clear-input');
                const searchButton = document.getElementById('search-button');
                
                // Search input change handler
                searchInput.addEventListener('input', () => {
                    const val = searchInput.value.trim();
                    
                    // Show/hide clear button
                    clearButton.style.display = val ? 'block' : 'none';
                    
                    // Add class for coordinate styling
                    const coordPattern = this.getCoordinatePattern();
                    if (coordPattern.test(val)) {
                        searchInput.classList.add('is-coordinates');
                    } else {
                        searchInput.classList.remove('is-coordinates');
                    }
                });
                
                // Clear button handler
                clearButton.addEventListener('click', () => {
                    searchInput.value = '';
                    searchInput.classList.remove('is-coordinates');
                    clearButton.style.display = 'none';
                    searchInput.focus();
                    this.logger.debug('Search input cleared');
                });
                
                // Search button click handler with debouncing
                const debouncedSearch = this.debounce(() => this.performSearch(), 500);
                searchButton.addEventListener('click', debouncedSearch);
                
                // Search input key handler with debouncing
                searchInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        debouncedSearch();
                    }
                });
                
                // Create debounced update function with longer delay
                this.debouncedUpdateGlideTable = this.debounce(this.updateGlideTableCoordinates.bind(this), 1000); // Increased from 500ms to 1000ms
                
                // Throttle window resize events
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        this.logger.debug('Window resized (debounced)');
                        if (this.map) {
                            this.map.resize();
                        }
                    }, 500);
                });
                
                // Clean up resources when page is unloaded
                window.addEventListener('beforeunload', () => {
                    this.logger.info('Page unloading, cleaning up resources');
                    if (this.map) {
                        this.map.remove();
                    }
                });
                
                this.logger.info('Event listeners setup complete');
            }
            
            /**
             * Perform search based on user input
             */
            performSearch() {
                const searchInput = document.getElementById('search-input');
                const val = searchInput.value.trim();
                
                if (!val) {
                    this.logger.debug('Search performed with empty input');
                    return;
                }
                
                this.logger.info('Performing search', { query: val });
                
                // Check if input is coordinates
                const coordPattern = this.getCoordinatePattern();
                const match = val.match(coordPattern);
                
                if (match) {
                    const latitude = parseFloat(match[1]);
                    const longitude = parseFloat(match[5]);
                    
                    this.logger.debug('Detected coordinate input', { lat: latitude, lng: longitude });
                    
                    if (this.isValidCoordinate(latitude, longitude)) {
                        this.map.flyTo({
                            center: [longitude, latitude],
                            zoom: 15,
                            essential: true
                        });
                        
                        this.addOrUpdateMarker(longitude, latitude);
                        
                        // Delay updating Glide table until map movement is complete
                        this.map.once('moveend', () => {
                            this.debouncedUpdateGlideTable(latitude, longitude);
                        });
                        
                        this.showStatus(`Coordinates: ${latitude.toFixed(6)}, ${longitude.toFixed(6)}`, 'success');
                        this.logger.info('Navigated to coordinates', { lat: latitude, lng: longitude });
                    } else {
                        this.showStatus('Invalid coordinates', 'error');
                        this.logger.warn('Invalid coordinates entered', { lat: latitude, lng: longitude });
                    }
                } else {
                    // Forward geocode the address
                    this.geocodeAddress(val);
                }
            }
            
            /**
             * Forward geocoding function to convert address to coordinates
             */
            geocodeAddress(query) {
                if (!query) return;
                
                this.logger.info('Geocoding address', { query });
                const loadingStatus = this.showStatus('Searching...', 'loading', 0);
                
                // Call the Mapbox Geocoding API
                fetch(`https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(query)}.json?access_token=${this.config.mapboxToken}&limit=1`)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`${response.status} ${response.statusText}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        loadingStatus.style.display = 'none';
                        
                        if (data.features && data.features.length > 0) {
                            const feature = data.features[0];
                            const [longitude, latitude] = feature.center;
                            
                            this.logger.info('Geocoding successful', { 
                                place: feature.place_name,
                                coordinates: { lat: latitude, lng: longitude }
                            });
                            
                            this.map.flyTo({
                                center: [longitude, latitude],
                                zoom: 15,
                                essential: true
                            });
                            
                            this.addOrUpdateMarker(longitude, latitude);
                            
                            // Delay updating Glide table until map movement is complete
                            this.map.once('moveend', () => {
                                this.debouncedUpdateGlideTable(latitude, longitude);
                            });
                            
                            this.showStatus(`Location found: ${feature.place_name}`, 'success');
                        } else {
                            this.logger.warn('No geocoding results found', { query });
                            this.showStatus('No results found', 'error');
                        }
                    })
                    .catch(error => {
                        loadingStatus.style.display = 'none';
                        this.logger.error('Geocoding error', { query, error: error.message });
                        this.showStatus(`Search error: ${error.message}`, 'error');
                    });
            }
            
            /**
             * Handle map click event
             */
            handleMapClick(e) {
                const latitude = e.lngLat.lat;
                const longitude = e.lngLat.lng;
                
                this.logger.info('Map clicked', { lat: latitude, lng: longitude });
                
                // Check if enough time has passed since the last update
                const now = Date.now();
                if (now - this.lastMapUpdate < 1000) {
                    this.logger.debug('Map click throttled (too soon after previous update)');
                    return;
                }
                
                this.lastMapUpdate = now;
                this.addOrUpdateMarker(longitude, latitude);
                
                // Don't update Glide table if map movement is in progress
                if (!this.mapMoveInProgress) {
                    this.debouncedUpdateGlideTable(latitude, longitude);
                } else {
                    this.logger.debug('Delaying Glide update until map movement completes');
                    this.map.once('moveend', () => {
                        this.debouncedUpdateGlideTable(latitude, longitude);
                    });
                }
            }
            
            /**
             * Add or update marker on the map
             */
            addOrUpdateMarker(longitude, latitude) {
                if (this.marker) {
                    this.logger.debug('Removing existing marker');
                    this.marker.remove();
                }
                
                this.logger.info('Adding marker', { lat: latitude, lng: longitude });
                
                this.marker = new mapboxgl.Marker({
                    draggable: true,
                    color: '#3880ff'
                })
                .setLngLat([longitude, latitude])
                .addTo(this.map);
                
                // Track marker drag state
                let markerDragInProgress = false;
                
                // Update coordinates when marker drag starts
                this.marker.on('dragstart', () => {
                    markerDragInProgress = true;
                    this.logger.debug('Marker drag started');
                });
                
                // Update coordinates when marker is dragged with debouncing
                this.marker.on('dragend', this.debounce(() => {
                    markerDragInProgress = false;
                    const lngLat = this.marker.getLngLat();
                    
                    this.logger.info('Marker dragged to new position (debounced)', { 
                        lat: lngLat.lat, 
                        lng: lngLat.lng 
                    });
                    
                    this.showStatus(`Coordinates: ${lngLat.lat.toFixed(6)}, ${lngLat.lng.toFixed(6)}`, 'success', 2000);
                    
                    // Only update if enough time has passed since last update
                    const now = Date.now();
                    if (now - this.lastMapUpdate >= 1000) {
                        this.lastMapUpdate = now;
                        this.debouncedUpdateGlideTable(lngLat.lat, lngLat.lng);
                    } else {
                        this.logger.debug('Marker update throttled (too soon after previous update)');
                    }
                }, 300));
                
                return this.marker;
            }
            
            /**
             * Update coordinates in Glide table
             */
            updateGlideTableCoordinates(latitude, longitude) {
                if (!this.isValidCoordinate(latitude, longitude)) {
                    this.logger.error('Invalid coordinates for Glide update', { lat: latitude, lng: longitude });
                    this.showStatus('Invalid coordinates', 'error');
                    return;
                }
                
                // Check if another update is already in progress
                if (this._updateInProgress) {
                    this.logger.debug('Skipping Glide update - another update already in progress');
                    return;
                }
                
                this._updateInProgress = true;
                
                this.logger.info('Updating Glide table coordinates', { 
                    lat: latitude, 
                    lng: longitude,
                    appId: this.config.appId,
                    tableId: this.config.tableId,
                    rowId: this.config.rowId,
                    columnName: this.config.columnName
                });
                
                const loadingStatus = this.showStatus('Updating coordinates...', 'loading', 0);
                
                const endpoint = 'https://api.glideapp.io/api/function/mutateTables';
                
                const headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.config.glideToken}`
                };
                
                const data = {
                    appID: this.config.appId,
                    mutations: [
                        {
                            kind: "set-columns-in-row",
                            tableName: this.config.tableId,
                            columnValues: {
                                [this.config.columnName]: `${latitude},${longitude}`
                            },
                            rowID: this.config.rowId
                        }
                    ]
                };
                
                // Display request details in debug console
                this.logger.debug('Glide API Request', {
                    url: endpoint,
                    method: 'POST',
                    headers: {...headers, 'Authorization': 'Bearer [HIDDEN]'},
                    body: data
                });
                
                // Add network monitoring to the debug console
                const requestStartTime = Date.now();
                
                // Use the fetch API with detailed monitoring
                fetch(endpoint, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(data)
                })
                .then(response => {
                    const requestDuration = Date.now() - requestStartTime;
                    
                    // Log response metadata before parsing
                    this.logger.debug('Glide API Response received', {
                        status: response.status,
                        statusText: response.statusText,
                        headers: Array.from(response.headers.entries()).reduce((obj, [key, val]) => {
                            obj[key] = val;
                            return obj;
                        }, {}),
                        duration: `${requestDuration}ms`
                    });
                    
                    this._updateInProgress = false;
                    
                    // Clone the response so we can log it and still return it
                    const responseClone = response.clone();
                    
                    // Process response for error handling
                    if (!response.ok) {
                        throw new Error(`${response.status} ${response.statusText}`);
                    }
                    
                    // Parse response JSON and log full details
                    return Promise.all([
                        response.json(),
                        responseClone.text()  // Get raw text for logging
                    ]);
                })
                .then(([responseData, rawResponse]) => {
                    // Log full API response
                    this.logger.debug('Glide API Response body', {
                        parsed: responseData,
                        raw: rawResponse
                    });
                    
                    loadingStatus.style.display = 'none';
                    this.logger.info('Glide table updated successfully', { 
                        response: responseData,
                        coordinates: `${latitude},${longitude}`
                    });
                    
                    // Add success indicator to the debug console
                    document.getElementById('debug-console').insertAdjacentHTML('beforeend', 
                        `<p class="log-info" style="color:green; font-weight:bold;">
                             Glide API call successful at ${new Date().toLocaleTimeString()}
                        </p>`
                    );
                    
                    this.showStatus('Location coordinates retrieved', 'success');
                    
                    // Trigger a custom event that can be listened for
                    const event = new CustomEvent('glideApiSuccess', {
                        detail: {
                            latitude,
                            longitude,
                            response: responseData
                        }
                    });
                    document.dispatchEvent(event);
                })
                .catch(error => {
                    this._updateInProgress = false;
                    loadingStatus.style.display = 'none';
                    
                    // Enhanced error logging
                    this.logger.error('Error updating Glide table', { 
                        error: error.message,
                        stack: error.stack,
                        request: {
                            endpoint,
                            data
                        }
                    });
                    
                    // Add failure indicator to the debug console
                    document.getElementById('debug-console').insertAdjacentHTML('beforeend', 
                        `<p class="log-error" style="color:red; font-weight:bold;">
                             Glide API call failed at ${new Date().toLocaleTimeString()}: ${error.message}
                        </p>`
                    );
                    
                    this.showStatus(`Error updating location: ${error.message}`, 'error');
                    
                    // Trigger a custom event that can be listened for
                    const event = new CustomEvent('glideApiError', {
                        detail: {
                            error: error.message,
                            latitude,
                            longitude
                        }
                    });
                    document.dispatchEvent(event);
                    
                    // Suggest troubleshooting steps
                    console.info('Troubleshooting tips for Glide API errors:');
                    console.info('1. Check if your Glide token is valid and not expired');
                    console.info('2. Verify the app ID, table ID, row ID, and column name exist and are spelled correctly');
                    console.info('3. Ensure the column type in Glide is compatible with coordinate strings');
                    console.info('4. Check your browser console for CORS-related errors');
                    console.info('5. Try opening the Debug Console to view detailed request/response data');
                });
            }
            
            /**
             * Show status message to user
             */
            showStatus(message, type = 'success', duration = 3000) {
                const statusElement = document.getElementById('status-message');
                statusElement.textContent = message;
                statusElement.className = type;
                statusElement.style.display = 'block';
                
                this.logger.debug('Status message shown', { message, type, duration });
                
                if (duration > 0) {
                    setTimeout(() => {
                        statusElement.style.display = 'none';
                    }, duration);
                }
                
                return statusElement;
            }
            
            /**
             * Check if coordinates are valid
             */
            isValidCoordinate(lat, lng) {
                return !isNaN(lat) && !isNaN(lng) && 
                       lat >= -90 && lat <= 90 && 
                       lng >= -180 && lng <= 180;
            }
            
            /**
             * Get coordinate pattern for validation
             */
            getCoordinatePattern() {
                return /^\s*([-+]?([1-8]?\d(\.\d+)?|90(\.0+)?)),\s*([-+]?(180(\.0+)?|((1[0-7]\d(\.\d+)?)|([1-9]?\d(\.\d+)?))))\s*$/;
            }
            
            /**
             * Debounce function to limit API calls
             * Enhanced version with improved handling for rapid successive calls
             */
            debounce(func, delay) {
                let timeout;
                return function(...args) {
                    const context = this;
                    clearTimeout(timeout);
                    timeout = setTimeout(() => {
                        timeout = null;
                        func.apply(context, args);
                    }, delay);
                };
            }
            
            /**
             * Handle initialization error
             */
            handleInitializationError(error) {
                // Log detailed error info
                console.error('INITIALIZATION ERROR:', error);
                
                try {
                    // Display detailed error information for debugging
                    const errorDetails = {
                        message: error.message,
                        stack: error.stack,
                        url: window.location.href
                    };
                    
                    // Try to parse URL params to see what's missing
                    const urlParams = new URLSearchParams(window.location.search);
                    const params = {};
                    for (const [key, value] of urlParams.entries()) {
                        // Don't log full token values for security
                        if (key.toLowerCase().includes('token') && value.length > 10) {
                            params[key] = value.substring(0, 5) + '...' + value.substring(value.length - 5);
                        } else {
                            params[key] = value;
                        }
                    }
                    errorDetails.params = params;
                    
                    console.error('Error details:', errorDetails);
                    
                    // Check which required params are missing
                    const requiredParams = ['mapboxToken', 'glideToken', 'appId', 'tableId', 'rowId', 'columnName'];
                    const missingParams = requiredParams.filter(param => !urlParams.get(param));
                    
                    let errorMessage = error.message;
                    if (missingParams.length > 0) {
                        errorMessage = `Missing required parameters: ${missingParams.join(', ')}`;
                    }
                    
                    // Show error in UI
                    document.getElementById('loading-overlay').innerHTML = 
                        `<div style="text-align: center; padding: 20px;">
                            <h3>Error Initializing Map</h3>
                            <p>${errorMessage}</p>
                            <div style="margin: 15px 0; text-align: left; background: #f8f8f8; padding: 10px; border-radius: 4px; max-width: 600px; margin: 0 auto; overflow: auto;">
                                <h4 style="margin-top: 0;">Parameters Found:</h4>
                                <pre style="margin: 0;">${JSON.stringify(params, null, 2)}</pre>
                            </div>
                            <button onclick="location.reload()" style="margin-top: 15px;">Reload Page</button>
                        </div>`;
                } catch (displayError) {
                    // Fallback if error display logic itself fails
                    console.error('Error while displaying error:', displayError);
                    document.getElementById('loading-overlay').innerHTML = 
                        `<div style="text-align: center; padding: 20px;">
                            <h3>Error Initializing Map</h3>
                            <p>${error.message}</p>
                            <p>Check console for more details.</p>
                            <button onclick="location.reload()">Reload Page</button>
                        </div>`;
                }
            }
        }
        
        // Initialize application when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            try {
                // Make logger available to console for debugging
                window.logger = new Logger();
                
                // Start the application and make it globally accessible
                window.app = new LocationPicker();
                
                // Add a global helper for quick API tests from console
                window.testGlideAPI = function(latitude = 37.7749, longitude = -122.4194) {
                    console.log(`Testing Glide API with coordinates: ${latitude},${longitude}`);
                    if (window.app) {
                        window.app.updateGlideTableCoordinates(latitude, longitude);
                        return true;
                    } else {
                        console.error('App not initialized, cannot test API');
                        return false;
                    }
                };
                
                // Enable CORS information in errors
                window.addEventListener('error', function(e) {
                    if (e && e.target && e.target.tagName === 'SCRIPT' && e.target.src) {
                        console.error('Script error from:', e.target.src);
                    }
                });
            } catch (error) {
                console.error('Fatal application error:', error);
                document.getElementById('loading-overlay').innerHTML = 
                    `<div style="text-align: center; padding: 20px;">
                        <h3>Fatal Error</h3>
                        <p>${error.message}</p>
                        <p style="color: #777; font-size: 12px;">Stack: ${error.stack ? error.stack.split('\n')[0] : 'Not available'}</p>
                        <button onclick="location.reload()">Reload Page</button>
                    </div>`;
            }
        });
    </script>
</body>
</html>
